<!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="utf-8">
            <title>HEBitmap Lua Docs</title>
            <meta name="viewport" content="width=device-width, initial-scale=1" />
            <link rel="stylesheet" href="style.css">
        </head>
        <body><div class="container"><h1>HEBitmap Lua Docs</h1><section><h2>‚öôÔ∏è Initialization</h2><div class="definition"><div class="definition-title">void he_library_init(PlaydateAPI *pd, int enableLua);</div><div class="definition-description">Initialize the library in C, call it in kEventInitLua. Pass 1 as the second parameter to enable Lua support.</div></div></section><section><h2>üé® Graphics</h2><div class="definition"><div class="definition-title">he.graphics.setClipRect(x, y, w, h)</div><div class="definition-description">Set the clip rect.</div></div><div class="definition"><div class="definition-title">he.graphics.clearClipRect()</div><div class="definition-description">Clear the clip rect.</div></div><div class="definition"><div class="definition-title">he.graphics.pushContext()</div><div class="definition-description">Push the graphics context.</div></div><div class="definition"><div class="definition-title">he.graphics.popContext()</div><div class="definition-description">Pop the graphics context.</div></div></section><section><h2>üñºÔ∏è Bitmap</h2><div class="definition"><div class="definition-title">he.bitmap.new(path)</div><div class="definition-description">Loads a new HEBitmap from a Playdate image file (similar to playdate.graphics.image.new).</div></div><div class="definition"><div class="definition-title">he.bitmap.loadHEB(path)</div><div class="definition-description">Loads a new HEBitmap from a .heb file (use the Python encoder to create it). Heb files are faster to load but larger on disk compared to the Playdate image format.</div></div><div class="definition"><div class="definition-title">he.bitmap:draw(x, y)</div><div class="definition-description">Draws the bitmap at the given position.</div></div><div class="definition"><div class="definition-title">he.bitmap:getSize()</div><div class="definition-description">Gets bitmap size as (width, height).</div></div><div class="definition"><div class="definition-title">he.bitmap:colorAt(x, y)</div><div class="definition-description">Gets the color at the given position. It returns a Playdate color such as <i>playdate.graphics.kColorBlack</i>.</div></div></section><section><h2>üñºÔ∏è Bitmap Table</h2><div class="definition"><div class="definition-title">he.bitmaptable.load(path)</div><div class="definition-description">Loads a new HEBitmap from a Playdate image table file (similar to playdate.graphics.imagetable.new).</div></div><div class="definition"><div class="definition-title">he.bitmaptable.loadHEBT(path)</div><div class="definition-description">Loads a new HEBitmapTable from a .hebt file (use the Python encoder to create it).</div></div><div class="definition"><div class="definition-title">he.bitmaptable:getBitmap(index)</div><div class="definition-description">Gets the bitmap at the given index in a table (1-based indexing).</div></div><div class="definition"><div class="definition-title">he.bitmaptable:getLength()</div><div class="definition-description">Gets the table length.</div></div></section><section><h2>üëæ Sprite system</h2><div class="note">The sprite system allows to efficiently move, check collisions and draw sprites.</div><div class="note">It's optional. If you don't want to include it, open <span class="inline-quote">he_api.h</span> and comment out <span class="inline-quote">#define HE_SPRITE_MODULE</span>. You can then remove <span class="inline-quote">he_sprite.h/c</span> from your project.</div></section><section><h2>Sprite basics</h2><div class="definition"><div class="definition-title">he.sprite.new()</div><div class="definition-description">Creates a new sprite. You can create your own sprite instance by extending <i>HESprite</i><pre class="code">class("Player").extends("HESprite")

local player = Player()
player:setBitmap(bitmap)</pre></div></div><div class="definition"><div class="definition-title">he.sprite:add()</div><div class="definition-description">Adds the sprite to the system. This is required.</div></div><div class="definition"><div class="definition-title">he.sprite:setBitmap(bitmap)</div><div class="definition-description">Sets a bitmap for the sprite.</div></div><div class="definition"><div class="definition-title">he.sprite:setPosition(x, y)</div><div class="definition-description">Sets the sprite position ignoring collisions.</div></div><div class="definition"><div class="definition-title">he.sprite:moveTo(x, y)</div><div class="definition-description">Moves the sprite.</div></div><div class="definition"><div class="definition-title">he.sprite:setCenter(cx, cy)</div><div class="definition-description">Sets the sprite center as a fraction in the range 0.0 - 1.0.</div></div><div class="definition"><div class="definition-title">he.sprite:setZIndex(z)</div><div class="definition-description">Sets the z-index for the sprite. Default value is 0.</div></div><div class="definition"><div class="definition-title">he.sprite:getPosition()</div><div class="definition-description">Gets the sprite position.</div></div><div class="definition"><div class="definition-title">he.sprite:getSize()</div><div class="definition-description">Gets the sprite size.</div></div><div class="definition"><div class="definition-title">he.sprite:remove()</div><div class="definition-description">Removes the sprite from the system.<br>Removing a sprite could be slow. If you plan to reuse it, consider hiding your sprite instead.</div></div></section><section><h2>Functions</h2><div class="definition"><div class="definition-title">he.sprite.move(deltaTime)</div><div class="definition-description">Call this function to move the sprites and check the collisions. Pass a delta time as the first parameter.</div></div><div class="definition"><div class="definition-title">he.sprite.update()</div><div class="definition-description">Call this function to determine the visible sprites.</div></div><div class="definition"><div class="definition-title">he.sprite.draw()</div><div class="definition-description">Call this function to draw the sprites. You are responsible to clear the screen before drawing.</div></div><div class="definition"><div class="definition-title">he.sprite.resizeGrid(x, y, w, h, cellSize)</div><div class="definition-description">A grid-based partioning system is used to determine collisions and visibility. Call this method to resize the grid and adapt it to your game. Resizing the grid could be slow, consider calling it before adding the sprites.<br><br>The default rect is (0, 0, display_width, display_height) with cellSize = 64.</div></div><div class="definition"><div class="definition-title">he.sprite.getAll()</div><div class="definition-description">Gets all the sprites. You shouldn't free the returned array.</div></div><div class="definition"><div class="definition-title">he.sprite.removeAll()</div><div class="definition-description">Removes all the sprites.</div></div><div class="definition"><div class="definition-title">he.sprite.setDrawOffset(dx, dy)</div><div class="definition-description">Set the draw offset, this is the same as moving a camera in a world (e.g. a player moving horizontally in a platform game).</div></div><div class="definition"><div class="definition-title">he.sprite.setScreenClipRect(x, y, w, h)</div><div class="definition-description">Set a screen clip rect.</div></div></section></section><section><h2>Sprite full docs</h2><div class="definition"><div class="definition-title">he.sprite:setTileBitmap(bitmap)</div><div class="definition-description">Sets a bitmap to be used as a tile (repeated bitmap).</div></div><div class="definition"><div class="definition-title">he.sprite:setTileOffset(dx, dy)</div><div class="definition-description">Sets the tile offset. For example, you can use it to scroll a repeated background.</div></div><div class="definition"><div class="definition-title">he.bitmap:setDrawCallback(callback)</div><div class="definition-description">Sets a draw callback to customize the drawing. Drawing coordinates are relative to the sprite. Remember to set a size for the sprite to use it.<pre class="code">he.bitmap:setDrawCallback(function(sprite, x, y, w, h)
	gfx.setColor(gfx.kColorBlack)
	gfx.fillRect(0, 0, w, h)
end)</pre></div></div><div class="definition"><div class="definition-title">he.sprite:setEmpty()</div><div class="definition-description">Sets a sprite as empty. This is the default state when a new sprite is created and not configured.</div></div><div class="definition"><div class="definition-title">he.sprite:setSize(width, height)</div><div class="definition-description">Sets the size for the sprite. This method has no effect if a bitmap is set.</div></div><div class="definition"><div class="definition-title">he.sprite:isVisible()</div><div class="definition-description">Gets the sprite visibility.</div></div><div class="definition"><div class="definition-title">he.sprite:isVisibleOnScreen()</div><div class="definition-description">Returns true if the sprite is currently visible on screen. It should be called after he.sprite.update()</div></div><div class="definition"><div class="definition-title">he.sprite:setClipRect(x, y, w, h)</div><div class="definition-description">Sets a clip rect for the sprite.</div></div><div class="definition"><div class="definition-title">he.sprite:setClipRectReference(reference);</div><div class="definition-description">Set the reference used to calculate the clip rect (relative or absolute). Default value is <i>relative</i> which means that the clip rect is in local coordinates. If you set <i>absolute</i>, the clip rect is in screen coordinates.<pre class="code">he.sprite.kClipRectRelative
he.sprite.kClipRectAbsolute</pre></div></div><div class="definition"><div class="definition-title">he.sprite:clearClipRect()</div><div class="definition-description">Clears the clip rect for the sprite.</div></div><div class="definition"><div class="definition-title">he.sprite:setIgnoresDrawOffset(flag)</div><div class="definition-description">Call this method to ignore the draw offset. Useful for UI elements or a background sprite at a fixed position.</div></div><div class="definition"><div class="definition-title">he.sprite:setIgnoresScreenClipRect(flag)</div><div class="definition-description">Call this method to ignore the screen clip rect.</div></div><div class="definition"><div class="definition-title">he.sprite:setUpdateCallback(callback)</div><div class="definition-description">Set an update callback for the sprite. The update callback is called only when the sprite is visible on screen.<pre class="code">sprite:setUpdateCallback(function(sprite)
	--update the sprite
end)</pre></div></div></section><section><h2>üí• Collisions</h2><div class="definition"><div class="definition-title">he.sprite:setCollisionsEnabled(flag)</div><div class="definition-description">Enable or disable the collisions for the sprite. By default, collisions are not enabled.</div></div><div class="definition"><div class="definition-title">he.sprite:setCollisionType(type)</div><div class="definition-description">Set the collision type, you can pass in a constant or a function to be used as a callback.<br><br>Example with a constant. This is the preferred and most efficient way.<pre class="code">sprite:setCollisionType(he.sprite.kCollisionTypeSlide)</pre>Example with a callback. By default, the result of the callback is cached and should be invalidated when needed.<pre class="code">sprite:setCollisionType(function(sprite, otherSprite)
	return he.sprite.kCollisionTypeOverlap
end)</pre>For the best performance, set or return <i>he.sprite.kCollisionTypeIgnore</i> if you don't need collisions detection for a specific pair.</div></div><div class="indent"><section><h2>Types</h2><div class="definition"><div class="definition-title">he.sprite.kCollisionTypeSlide</div><div class="definition-description">Set slide if you want the sprite to slide over other sprites.</div></div><div class="definition"><div class="definition-title">he.sprite.kCollisionTypeFreeze</div><div class="definition-description">Set freeze if you want the sprite to stop when touches other sprites.</div></div><div class="definition"><div class="definition-title">he.sprite.kCollisionTypeOverlap</div><div class="definition-description">Set overlap if you want to get notified when the sprite collides with other sprites.</div></div><div class="definition"><div class="definition-title">he.sprite.kCollisionTypeBounce</div><div class="definition-description">Set bounce if you want the sprite to bounce touching other sprites.</div></div><div class="definition"><div class="definition-title">he.sprite.kCollisionTypeIgnore</div><div class="definition-description">Set ignore if you want to ignore the collision early and skip other calculations (good for performance).</div></div></section></div><div class="definition"><div class="definition-title">he.sprite:getCollisionType()</div><div class="definition-description">Gets the collision type.</div></div><div class="definition"><div class="definition-title">he.sprite:invalidateCollisionType()</div><div class="definition-description">It invalidates the cached collision type (only if you use a callback).</div></div><div class="definition"><div class="definition-title">he.sprite:cacheCollisionType(flag)</div><div class="definition-description">Enable or disable the cache for the collision type callback. In Lua, the cache is enabled by default.</div></div><div class="definition"><div class="definition-title">he.sprite:collisionTypeIsBeingCached()</div><div class="definition-description">Returns true if the cache is enabled for the collision type callback.</div></div><div class="definition"><div class="definition-title">he.sprite:setFastCollisions(flag)</div><div class="definition-description">Enable or disable fast collisions for the sprite. If enabled, detection will be faster but tunnelling won't be supported.</div></div><div class="definition"><div class="definition-title">he.sprite.getCollisions() -> collisions, length</div><div class="definition-description">Get the collisions occurred in the latest move call. It returns an array of <i>he.spritecollision</i> objects and a length.</div></div><div class="indent"><section><h2>Collision</h2><div class="definition"><div class="definition-title">he.spritecollision:getType()</div><div class="definition-description">Gets the collision type.</div></div><div class="definition"><div class="definition-title">he.spritecollision:getSprite()</div><div class="definition-description">Gets the sprite being moved.</div></div><div class="definition"><div class="definition-title">he.spritecollision:getOtherSprite()</div><div class="definition-description">Gets the other sprite.</div></div><div class="definition"><div class="definition-title">he.spritecollision:getNormal() -> nx, ny</div><div class="definition-description">Returns the two components of the normal (nx, ny). Allowed values are: -1, 0, 1. You can use it to determine which side collided with the other sprite. For nx, -1 is the left side, 1 is the right side. For ny, 1 is the bottom side, -1 is the top side.</div></div><div class="definition"><div class="definition-title">he.spritecollision:getTouch()</div><div class="definition-description">Gets the sprite position where it started touching other.</div></div><div class="definition"><div class="definition-title">he.spritecollision:getGoal()</div><div class="definition-description">Gets the goal position for the sprite.</div></div><div class="definition"><div class="definition-title">he.spritecollision:getRect()</div><div class="definition-description">Gets the sprite rect where it started touching other.</div></div><div class="definition"><div class="definition-title">he.spritecollision:getOtherRect()</div><div class="definition-description">Gets the other sprite rect where it started touching sprite.</div></div></section></div><div class="definition"><div class="definition-title">he.sprite:checkCollisions() -> collisions, length</div><div class="definition-description">Returns an array of collisions like <i>he.sprite.getCollisions()</i> but without moving the sprite.</div></div><div class="definition"><div class="definition-title">he.sprite.queryWithRect(x, y, w, h) -> sprites, len</div><div class="definition-description">Returns all the sprites (with collisions enabled) in the given rect.</div></div><div class="definition"><div class="definition-title">he.sprite.queryWithSegment(x1, y1, x2, y2) -> sprites, len</div><div class="definition-description">Returns all the sprites (with collisions enabled) intersecting the given segment.</div></div><div class="definition"><div class="definition-title">he.sprite.queryWithPoint(x, y) -> sprites, len</div><div class="definition-description">Returns all the sprites (with collisions enabled) containing the given point.</div></div></section><section><h2>‚û°Ô∏è Animation</h2><div class="definition"><div class="definition-title">he.sprite:setFollowTarget(sprite)</div><div class="definition-description">Sets a target to follow. Pass nil to unfollow the current target.</div></div><div class="definition"><div class="definition-title">he.sprite:setFollowVelocity(velocity)</div><div class="definition-description">Sets the velocity with which the target is followed (pixel per second).</div></div><div class="definition"><div class="definition-title">he.sprite:setFollowOffset(dx, dy)</div><div class="definition-description">Sets an offset for the target position. Offset is calculated from the center of the sprite.</div></div><div class="definition"><div class="definition-title">he.sprite:setFollowRefreshRate(rate)</div><div class="definition-description">Sets a refresh rate in order to update the target position at regular intervals (sprite movement will be delayed).</div></div></section></div></body></html>